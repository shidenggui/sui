searchState.loadedDescShard("sui_indexer_alt_framework", 0, "Contains the error value\nCommand-line arguments for the indexer\nContains the success value\n<code>Result&lt;T, Error&gt;</code>\nAdds a new pipeline to this indexer and starts it up. …\nThe database connection pool used by the indexer.\nOverride for the checkpoint to start ingestion from – …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe ingestion client used by the indexer to fetch …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOverride for the checkpoint to end ingestion at …\nThe indexer’s metrics.\nCombine the provided <code>migrations</code> with the migrations …\nCreate a new instance of the indexer framework. …\nOnly run the following pipelines. If not provided, all …\nThe pipelines that this indexer will run.\nStart ingesting checkpoints. Ingestion either starts from …\nAdds a new pipeline to this indexer and starts it up. …\nDon’t write to the watermark tables for concurrent …\nThe <code>sql!</code> macro is used to construct a <code>diesel::SqlLiteral&lt;T&gt;</code>…\nBundle of arguments for setting up an indexer cluster (an …\nAn IndexerCluster combines an Indexer with a MetricsService…\nThis token controls stopping the indexer and metrics …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccess to the indexer’s metrics. This can be cloned …\nCreate a new cluster with most of the configuration set to …\nCreate a new cluster.\nStarts the indexer and metrics service, returning a handle …\nMaximum size of checkpoint backlog across all workers …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMaximum number of checkpoints to attempt to fetch …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPath to the local ingestion directory. If both …\nTODO: If we want to expose this as part of the framework, …\nRemote Store to fetch checkpoints from.\nPolling interval to retry fetching checkpoints that do not …\nSui fullnode gRPC url to fetch checkpoints from. If all …\nOptional password for the gRPC service.\nOptional username for the gRPC service.\nStart the ingestion service as a background task, …\nAdd a new subscription to the ingestion service. Note that …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nFetch checkpoint data by sequence number.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHow much concurrency to use when processing checkpoint …\nHow much concurrency to use when processing checkpoint …\nUsed to identify the pipeline in logs and metrics.\nImplementors of this trait are responsible for …\nThe type of value being inserted by the handler.\nThe collector will check for pending data at least this …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe processing logic for turning a checkpoint into rows of …\nWatermark task will check for pending watermarks this …\nNumber of concurrent writers per pipeline.\nConfiguration for a concurrent pipeline\nHandlers implement the logic for a given indexing …\nIf there are more than this many rows pending, the …\nIf at least this many rows are pending, the committer will …\nWhether the pruner requires processed values in order to …\nTake a chunk of values and commit them to the database, …\nConfiguration for the writer, that makes forward progress.\nHow long to wait after the reader low watermark was set, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nHow often the pruner should check whether there is any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum range to try and prune in one request, …\nClean up data between checkpoints <code>_from</code> and <code>_to_exclusive</code> …\nThe max number of tasks to run in parallel for pruning.\nConfiguration for the pruner, that deletes old data.\nHow much data to keep, this is measured in checkpoints.\nA type to combine multiple <code>Self::Value</code>-s into. This can be …\nHandlers implement the logic for a given indexing …\nMaximum number of checkpoints to try and write in a single …\nIf at least this many rows are pending, the committer will …\nConfiguration for a sequential pipeline\nAdd <code>values</code> from processing a checkpoint to the current …\nHow many checkpoints to hold back writes for.\nTake a batch of values and commit them to the database, …\nConfiguration for the writer, that makes forward progress.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHelper type for representing a boxed query from this table\nThe SQL type of all of the columns on this table\nA tuple of all of the columns on this table\nContains all of the columns of this table\nThe distinct clause of the query\nRe-exports all of the columns of this table, as well as the\nReturns the argument unchanged.\nThe from clause of the query\nThe group by clause of the query\nThe having clause of the query\nCalls <code>U::from(self)</code>.\nThe combined limit/offset clause of the query\nThe order clause of the query\nThe select clause of the query\nRepresents <code>table_name.*</code>, which is sometimes necessary for …\nThe actual table struct\nThe where clause of the query\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresents <code>table_name.*</code>, which is sometimes needed for …\nRepresents the highest checkpoint for some pipeline that …\nRepresents a database connection that can be used by the …\nA watermark that represents the bounds for the region that …\nRepresents the inclusive lower bound of available data in …\nA storage-agnostic interface that provides database …\nExtends the Store trait with transactional capabilities, …\nWithin the framework, this value is used to determine the …\nGiven a pipeline, return the committer watermark from the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe pruner has already deleted up to this checkpoint …\nGet the bounds for the region that the pruner is allowed …\nWithin the framework, this value is used to check whether …\nThe pruner can delete up to this checkpoint (exclusive).\nGiven a pipeline, return the reader watermark from the …\nUpsert the high watermark as long as it raises the …\nUpdate the pruner watermark, returns true if the watermark …\nUpdate the <code>reader_lo</code> of an existing watermark entry only …\nThe remaining time in milliseconds that the pruner must …\nExtension trait introducing <code>try_for_each_spawned</code> to all …\nAttempts to run this stream to completion, executing the …")